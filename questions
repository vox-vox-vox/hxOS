1. 事实上 Unbuffered I/O 这个名词是有些误导的，虽然 write 系统调用位于 C
标准库 I/O 缓冲区的底层，但在 write 的底层也可以分配一个内核 I/O 缓冲区，
所以 write 也不一定是直接写到文件的，也可能写到内核 I/O 缓冲区中，至于究
竟写到了文件中还是内核缓冲区中对于进程来说是没有差别的，如果进程 A 和
进程 B 打开同一文件，进程 A 写到内核 I/O 缓冲区中的数据从进程 B 也能读到，
而 C 标准库的 I/O 缓冲区则不具有这一特性（想一想为什么）。

2. 文件描述符（int）和FILE*
进程描述符=task_struct=PCB(process control block)
文件描述符表=file_struct,其中每一个表项包含一个指向已打开文件的指针。
文件描述符表=指针数组；文件描述符=指针数组的index
对于C标准IO库来说，打开的文件由FILE*标识；对内核来说打开的文件由文件描述符标识

3. 
	1. 内核和磁盘不在一起嘛
	2. 什么叫传给内核，内核再写回设备，这居然是两个过程
	3. 用户空间/内核空间，用户程序/内核，C标准IO缓冲区/磁盘 之间的关系
	4. 标准输入输出 和 终端设备有什么关系？ 

4. 阻塞
定义：进程调用函数发生阻塞时，进程被置为sleep状态，这时内核调度其他进程运行

读写常规文件不会发生阻塞，阻塞发生在读写终端和网络中
读终端时没有换行符，会发生阻塞
读网络请求，如果对面没有包过来，也会发生阻塞


5. 进程状态
sleep：
	阻塞
running：
	1. 正在被调度执行。CPU处于该进程的上下文环境中，程序计数器（eip）里保存着该进程
	的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，
	正在读写该进程的地址空间。
	2. 就绪状态。该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一
	个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进
	程，那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进
	程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，
	同时要兼顾用户体验，不能让和用户交互的进程响应太慢。

6. 重定向
	> B 将标准输出(输出到屏幕)重定向至输出至B
	>> B 重定向&追加
	< B 以B作为标准输入，也许是以B中的内容作为标准输入
重定向的本质是，进程的文件描述符表指向新的文件。比如说之前 文件描述符表[0] = stdin，经过输入重定向 (... < B)，文件描述符表[0] = B
	重定向也有新的语法：
	1. 2>B 将 文件描述符表[2] 处的文件指针指向B
	2. 2>&1 将 文件描述符表[2] 处的文件指针指向 文件描述符表[1] 处的地址
	
